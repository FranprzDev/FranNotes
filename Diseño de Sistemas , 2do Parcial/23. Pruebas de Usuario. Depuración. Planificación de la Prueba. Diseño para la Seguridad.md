# Pruebas de Usuario
Las pruebas de usuario son una etapa en el proceso de prueba donde los usuarios proporcionan entrada y asesoría sobre las pruebas del sistema.
Estas pueden ser de forma **formal** o **informal**; pero de cualquier forma son esenciales.

Existen 3 tipos de pruebas de usuario.
1) **Prueba alfa**: Los usuarios trabajan con el equipo de diseño para probar el soft en el sitio del desarrollador *(Aquí el panita thames dijo que jugabamos de "local" con los clientela)*. Estas se basan en los métodos ágiles para su desarrollo y que participen activamente, una vez mostrado al cliente, se va mejorando continuamente el sistema.
2) **Prueba beta**: Una versión del software se pone a disposición de los usuarios haciendo que permitan experimentar y descubrir los problemas. *(En este caso sería que jugamos de "visitante" los muchachos hacen sus cositas y si hay errores nos dicen de manera no amigable)*. No tan solo se puede ser con un cliente, podemos publicar nuestro producto y que alguien lo testee de forma "gratis" por nosotros, como las **Beta de Minecraft.**
3) **Pruebas de aceptación**: Son las siguientes a las pruebas de versión y el cliente prueba de manera formal su sistema donde decide si lo aceptará o no, en caso de aceptarla debe desembolsar la guita.

### Pruebas de aceptación
Tenemos 6 etapas en este proceso
![[Pasted image 20241123180106.png]]

1) **Definir criterios de aceptación**, es qué haremos con el tema de las pruebas; lo ideal sería que estén antes de firmar el contrato pero es difícil definir esto con antelación, así que tenemos que pegar una buena chamuyada.
2) **Plan de pruebas de aceptación**, decidir que recursos se gastará para las pruebas.
3) **Derivar las pruebas de aceptación**, para esto se establecen criterios de aceptación diseñando pruebas para comprobar si un sistema es aceptable o no.
4) **Correr pruebas de aceptación**, lo ideal es que ocurran en un entorno real, pero es difícil, pero son todas las apruebas acordadas sobre el sistema.
5) **Negociar los resultados de las pruebas**, en el caso de que todo esté okey y el sistema perfecto; pues genial, terminamos; pero en caso de que no habrá que negociar y ver que se puede "ignorar".
6) **Rechazo / aceptación del sistema** Es una reunión entre los clientes para decidir si el sistema debe aceptarse o no.

Todo esto es teórico, en la práctica difiere; pues todo dependerá de que onda con el cliente, si está apresurado en implementar el sistema o no le molesta; si es muy crítico, si es una **ruta roja** o lo que sea; así que todo esta sección es muy #Chamuyableu

# Depuración
<div style="color: red; font-size: 16px; font-weight: 700;">
	Disclaimer:
		<br>
	La depuración ya la escribí en el PDF anterior, y más o menos es lo que se necesita saber; se habla mucho aquí pero se dice poco, es poco conciso y además a día de hoy es inútil. Con algo en google zafa para chamuyar.
</div>

# Planificación de la prueba
Es necesaria una planificación cuidadosa para sacar el máximo provecho de inspecciones y pruebas así controlamos sus costos, ya que son procesos caros. El esfuerzo que dedicaremos a las pruebas; siempre dependerá del tipo de sistema que desarrollaremos.
Los **planes de prueba** incluyen contingencias, para que los desajustes puedan solucionarse y el personal pueda ser reasignado a otras actividades.

# Diseño para la seguridad
Es difícil agregar seguridad a un sistema después de que este sea implementado, debido a esto; se deben tomar en cuenta los riesgos de seguridad durante el proceso de diseño; cada aplicación es diferente y el diseño de seguridad debe tomarse en cuenta. La **redundancia** suele ser fundamental para ganar confiabilidad, pero es cara.
A medida que más seguridad metemos a nuestro sistema, perdemos usabilidad, de hecho hay una curva (La curva de Seg Informática que se puede chamuya).
También podemos hablar sobre la arq. de software con la que desarrollamos, que es algo importante también en la seguridad.

Al diseñar, debemos considerar:
- **Protección** ¿Cómo organizar el sistema para proteger activos críticos?
- **Distribución** ¿Cómo distribuiremos los activos del sistema para minimizar riesgos en posibles ataques?

A su vez podemos plantear 3 tipos de protecciones:
1) **Protección a nivel plataforma**: Ingreso de usuario a una computadora en particular.
2) **Protección a nivel aplicación**: Acceso de un usuario a la aplicación, su autenticación y la obtención del permiso para realizar acciones.
3) **Protección a nivel de registro**: Si se requiere acceso a registros específicos (algún historial clínico, o información importante).
Podemos utilizar encriptación si necesitamos.

No hay que ser tontos, y hay que ver para que sirve nuestro sistema, un requerimiento de confidencialidad puede ocasionar que la usabilidad se nos vaya al demonio, y viceversa.
