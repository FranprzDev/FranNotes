Las pruebas intentan demostrar que un programa hace lo que se intenta que haga y descubrir los defectos que este tiene antes de la implementación.
Lo importante de la prueba es buscar errores o anomalías.
Este proceso tiene dos metas distintas:
1) Demostrar al desarrollador y al cliente que el software cumple con los requerimientos. *(Para ello hacemos pruebas de validación)*
2) Encontrar situaciones donde el comportamiento del software sea incorrecto, indeseable o no este de acuerdo con su especificación *(Para esto hacemos pruebas de defecto)*

Existen distintos tipos de prueba:
- **Prueba de defectos** tienen como objetivo erradicar el comportamiento indeseable del sistema
- **Prueba de validación** esperar que el sistema se desempeñe de manera correcta mediante un conjunto dado de casos de prueba, que refleje el uso previsto del sistema.
Lo ideal de estas pruebas es que el sistema se pruebe como si fuera una **caja negra**, quiere decir que lo que nos importa es el resultado al final de la operación; teniendo en cuenta las entradas dadas y las salidas esperadas y lo que realmente salió.
Teniendo en cuenta el siguiente diagrama:
![[Pasted image 20241123143323.png]]

**Las pruebas no pueden demostrar que el software no tiene defectos o que se comportará como se especifica en cualquier circunstancia.**
Dijkstra dijo que **las pruebas pueden mostrar sólo la presencia de errores, más no su ausencia**.

## **V&V**
Las pruebas parten del proceso de **verificación** y **validación**.
- **Validación** > ¿Construimos el producto correcto?
- **Verificación** > ¿Construimos bien el producto?

Hay que comprobar que el software cumpla con las especificaciones y brinde la funcionalidad deseada, y estas comienzan ni bien estén los requerimientos y continúan durante el desarrollo.
La finalidad de la **verificación** es comprobar que el software cumpla con funcionalidad y requerimientos no funcionales establecidos.
La finalidad de la **validación** es un proceso más general que consiste en garantizar que el software cumpla con las expectativas del cliente.

El objetivo final de **V&V** es establecer confianza de que el software es el **"adecuado"**, y que es eficaz para su uso esperado, este nivel de confianza dependerá de:
- **El propósito del sistema:** Dependerá de que tan crítico sea el software, si es muy, deberá ser muy confiable.
- **Las expectativas de los usuarios:** Dependerá que tan acostumbrado a las fallas están los usuarios, estos pueden soportar fallas del sistema mientras los beneficios sean mayores que los costos.
- **El entorno del mercado:** Dependerá del mercado como tal, y considerando siempre la competencia que hay con ese producto; también teniendo en cuenta factores como el precio de nuestro software y que tan confiable debería ser por ese precio.

## **Pruebas estáticas y Pruebas Dinámicas**

### Pruebas estáticas
Podemos utilizar dos tipos, Inspecciones & Pruebas.
Las primeras se enfocan en el código fuente, pero podemos extrapolarlo también a correciones en diagramas, requerimientos, modelos, etc.

![[Pasted image 20241123144105.png]]

Existen 3 ventajas de realizar inspecciones:
1) **En las pruebas, los errores pueden ocultar fallas:** Al no ejecutarse nada; y ser un proceso estático no hay interacción entre errores; por lo tanto lo que se pruebe es una unidad únicamente, y esto puede descubrir muchos errores.
2) **Las versiones incompletas de un sistema se pueden inspeccionar**
3) **Una inspección puede tener en cuenta otros atributos de calidad, como el cumplimiento con estándares, portabilidad y mantenibilidad**

Hay que tener en cuenta que las inspecciones no sustituyen las pruebas del software, y no sirven para descubrir defectos por interacciones entre diferentes partes de un programa; problemas de temporización o rendimiento del sistema.

### Pruebas dinámicas
Un **caso de prueba** son especificaciones de entradas a la prueba y la salida esperada (resultados), e información de que se pone a prueba.
Existen los:
- **Datos de prueba:** entradas diseñadas para probar un sistema, que pueden ser generadas automáticamente o no.
Tenemos que tener **total conocimiento sobre lo que hace el sistema para especificar los resultados de prueba previstos.**
Lo ideal sería buscar la automatización de esto, es decir correr los test y listo.


## **Pruebas**
**Un sistema debe pasar por 3 etapas de prueba:**
1) **Pruebas de desarrollo: El sistema se va probando descubriendo bugs y defectos, mientras se programa aún.**
2) **Versiones de prueba: Un equipo de prueba separado experimenta una versión completa del sistema antes de presentarlo al usuario.**
3) **Pruebas de usuario: Son usuarios reales o potenciales que prueban nuestro sistema.**
	1) **Pruebas de aceptación: El cliente prueba de manera formal un sistema para decidir si lo acepta o requiere más desarrollo.**

**Existen otros tipos de prueba como:**
- **Pruebas automatizadas: Codificadas en algún tipo de programa y/o en el mismo lenguaje con un framework para probar el sistema como tal.  Estas pruebas son más rápidas que las manuales específicamente las pruebas de regresión, que consiste en correr las pruebas anteriores para comprobar que los cambios nuevos no introdujeron nuevos bugs.**
**Así mismo, se sabe que todas las pruebas no pueden ser automatizadas, y que lo que podemos automatizar es solamente lo que el programa se supone que debería hacer.**

## **Calidad del Diseño**

***“La gente olvida cuán rápido hiciste un trabajo, pero siempre recuerda cuán bien lo realizaste” (Howard Newton).***

La calidad del diseño son las características que los diseñadores especifican para un producto, esta se incrementa si se fabrica de acuerdo con las especificaciones.
***“La calidad de un producto está en función de cuánto cambia al mundo para bien” (DeMarco).***

Si es un soft es muy beneficioso para la organización, se omitirán problemas ocasionales de este mismo ya que el beneficio es mucho mayor que no tenerlo.

### Calidad del Software
Es la meta, y se define como el proceso eficaz de software que crea un producto útil, que proporciona valor medible a quienes lo producen y a quienes lo utilizan.

## **Pruebas de Unidad**
Son las que realiza el equipo que elabora el sistema, si estamos ante un sistema crítico lo ideal sería que lo haga un equipo por separado independiente.

#### **Pruebas de Desarrollo**
1) **Pruebas de Unidad:** Se prueban unidades de programa o clases de objetos individuales, estas comprueban la **funcionalidad de objetos o métodos.** Lo ideal con estas es buscar su automatización, ya que por lo general serán muchas 
2) **Pruebas de componente:** Se integran muchas unidades individuales, probando las **interfaces de los componentes**.
3) **Prueba del sistema:** Algunos o todos los componentes del sistema se integran y se prueba como un todo, así mismo se prueban las **interacciones entre los componentes**.

Las pruebas de **desarrollo** vienen entrelazadas con la **depuración**, que es el proceso de localizar problemas con el código mediante brekapoints y siguiendo paso a paso; así saber los valores de las variables en cada momento; y poder de este modo descubrir donde están los errores en el código

Un conjunto automatizado de pruebas tiene tres partes:
1) **Configuración** Son las entradas y salidas esperadas.
2) **Call** es la llamada al objeto o al método que se probará
3) **Declaración** comparar el resultado de la llamada con el esperado.
	1) Si el resultado es el esperado, pasó la pruebas.
	2) Si el resultado no es el esperado, no pasó las pruebas.

Tenemos que buscar tener **efectividad** ya que las pruebas son costosas y consumen tiempo.
Debido a esto tenemos que escribir 2 tipos de casos de prueba:
1) **Reflejar una operación normal de un programa y mostrar que el componente funciona.**
2) **Probar la experiencia de donde surgen problemas comunes**

Existen 2 estrategias efectivas para elegir los casos de prueba:
1) **Prueba de Partición** identificar grupos de entradas con características comunes y procesarlas de la misma forma.
2) **Pruebas basadas en lineamientos** reflejar la experiencia previa de los errores tipicos que suelen cometer los programadores al desarrollar componentes.

Gráfico sobre las pruebas y como funciona (ver pptx) #Skipeable 

**Lineamientos para revelear defectos**
- **Probar software con secuencias que tengan un valor único.**
- **Usar diferentes secuencias de diversos tamaños en distintas pruebas.**
- **Diseñar pruebas para acceder a los elementos: primero, medio y último de la secuencia.**