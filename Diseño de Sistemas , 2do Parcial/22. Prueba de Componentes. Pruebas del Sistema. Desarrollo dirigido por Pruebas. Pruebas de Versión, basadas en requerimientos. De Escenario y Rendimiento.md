# Prueba de Componentes
Para comprobar componentes lo que debemos hacer es probar las interfaces de cada uno y la integración de ellos.
Existen 4 tipos de interfaz entre componentes
1) **Interfaces de parámetro** los datos son pasados de componente a componente por medio de parámetros.
2) **Interfaces de memoria compartida** un bloque de memoria se reparte entre componentes. Los datos se colocan en la memoria de un subsistema y otros subsistemas los recuperan de ahí.
3) **Interfaces de procedimiento** un componente encapsula un conjunto de procedimientos que son llamados por otros.
4) **Interfaces que pasan mensajes** por medio de mensajes, un componente solicita un servicio de otro componente.
Así mismo podemos encontrar 3 clases de errores de interfaz:
- **Uso incorrecto de interfaz**, puede ser debido a un parámetro de tipo equivocado, o que se pasen en un orden equivocado.
- **Mala interpretación de interfaz**, el componente que se llamó no se comporta como se esperaba; es decir no es lo que se preveía.
- **Errores de temporización**, se descoordinan el uso de la memoria compartida de los mensajes.

**Lineamientos para pruebas de interfaz:** #Skipeablee
1) **Examinar el código a probar y listar explícitamente cada llamado a un componente externo.**
2) **Donde los punteros pasen a través de una interfaz, pruébela con valores nulos para los punteros**
3) **Si un componente se llama a través de interfaz de procedimiento, diseñe pruebas que deliberadamente hagan que falle el componente.**
4) **Use pruebas de esfuerzo en sistemas que pasan mensajes.**
5) **Si algunos componentes interactúan a través de memoria compartida**

# Pruebas del Sistema
**Integración y pruebas incrementales**
Las **pruebas del sistema** implican integrar diferentes componentes y después probar el sistema integrado que se creó; es un enfoque incremental para la integración y pruebas para esto se debe incluir un componente, probar el sistema, integrar otro componente, probar de nuevo y así iterativamente. En el caso de ocurrir problemas, hay que corregirlo y si no hacer un **rollback** a lo último que andaba.

Es importante que entendamos que nos basamos en la metodología de **XP** para hacer esto, así que sigue los mismos principios, la idea es que siempre estemos probando y en lo posible corriendo pruebas de regresión.

**Las pruebas de sistema demuestran que los componentes son compatibles, que interactúan correctamente y que transfieren los datos correctos en el momento adecuado a través de sus interfaces.** #Importante 

Aquí tenemos las **pruebas de interacción** que son las encargadas de descubrir los bugs de un componente que sólo se revelan cuando lo usan otros componentes.
También podemos realizar **pruebas basadas en casos ed uso** que son **pruebas del sistema efectivas**.

Es difícil saber que probar y que no probar; por que se podría probar todo pero no hay tiempo, a su vez tenemos ciertas **políticas de prueba:**
1. **Que todas las líneas del programa se ejecuten al menos una vez.** 
2. **Probar todas las funciones que se ingresen a través de un menú.** 
3. **Probar combinación de funciones que se ingresen por el mismo menú.** 
4. **Si hay entradas del usuario => probar entradas correctas e incorrectas.**

# Desarrollo dirigido por pruebas #Importante 
<div style="color: red;">
	<hr>
	Disclaimer:
	**Además de ser un tema interesante, es un tema muy importante en general; y dentro de todo lo más destacable de la materia verga esta**
	<hr>
</div>

Es un enfoque de diseño de programas, que se entrelaza con el desarrollo de pruebas; el código se desarrolla incrementalmente con una prueba sobre dicho código. El TDD es primero hago las pruebas y luego voy desarrollando; está bueno por que nuestro código queda **altamente documentado** y cumple con principios de XP; pero el principal problema de esto es que es muy lento, cuesta mucho y  necesitas **gente muy experimentada**.
**No cualquiera puede hacer TDD**

**Beneficios de TDD**
- **Código documentado,** los tests describen con exactitud que debe hacer el código.
- **Pruebas de regresión**, se verifica que los cambios añadidos no agreguen problemas al software.
- **Depuración simplfiicada,** si falla una prueba ya sabemos exactamente en que archivo anda el problema.
- **El código siempre estará documentado**, ya que cada integración viene con una prueba asociada.
Grafiquita de TDD
![[Pasted image 20241123173457.png]]

# Pruebas de Versión y basadas en requerimientos
Las pruebas de versión es el **proceso de poner a prueba una versión de un sistema fuera del equipo de desarrollo.** El objetivo de estas es comprobar que el sistema cumple con los requerimientos y es adecuado para su uso. Una prueba de versión puede liberar de por sí un producto o ya la entrega a un cliente.
Las pruebas de versión pertenecen al proceso de prueba de caja negra; y estas pruebas son derivadas a partir de la especificación del sistema; y el sistema se trata como una **caja negra**, cuyo comportamiento sólo puede determinarse estudiando las entradas y las salidas relacionadas.

## **Pruebas  basadas en requerimientos**
Todo requerimiento que fue relevado debe ser comprobable, se considera cada uno de estos y se derivada un conjunto de pruebas para ellas, estas **pruebas son de validación** que demuestran que el sistema implementó adecuadamente los requerimientos. Un requerimiento pueden ser muchas pruebas.

## **Pruebas de Escenario**
Está enfocada a las pruebas de versión; creando escenarios típicos de uso y con ellos desarrollando casos de prueba.
Un **escenario** no es más que una historia que describe una forma en que puede usarse el sistema, pero deben ser realistas estos escenarios. Una prueba de escenario incluye una **historia narrativa creíble y compleja.**

## **Pruebas de rendimiento**
Una vez que se integre todo el sistema, es importante probarlo, pero además haciendo énfasis en el **rendimiento** y en la **confiabilidad**, esto garantiza que el sistema procese la carga pretendida. Para esto podemos sobrecargar el sistema para ver si sigue funcionando como lo esperando.
Las pruebas de rendimiento no son más que estresar al sistema para forzar los límites del diseño de software; por eso son una **prueba de esfuerzo**
Este tipo de pruebas tiene 2 funciones:
1) **Prueba el comportamiento de falla del sistema**:
	1) Buscar una combinación inesperada de eventos donde la carga colocada en el sistema supere la máxima anticipada, y si este falla que no haya ningun problema con los criticidad del sistema que ofrecemos.
2) **Fuerza al sistema**
	1) Esto hace que salgan a la luz donde están los problemas específicos, es decir cuál es límite práctico donde el sistema da problemas con una cantidad X de transacciones.