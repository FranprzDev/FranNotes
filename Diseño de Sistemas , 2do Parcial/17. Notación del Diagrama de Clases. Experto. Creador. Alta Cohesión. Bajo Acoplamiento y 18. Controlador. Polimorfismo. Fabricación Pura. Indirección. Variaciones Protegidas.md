
Esto es muy importante, por que seguro va alguno de estos.

#Importante
# Patrones de Diseño:
##  Experto 

- **Problema:** ¿Cuál es un principio general para asignar responsabilidades?
- **Solución:** Asignar una responsabilidad al experto, es decir, la clase que tiene la información necesaria para realizar la responsabilidad.
## Creador

- **Problema:** ¿Quién debería ser responsable de crear una nueva instancia de alguna clase?
- **Solución:** Asignar a la clase B la responsabilidad de crear una instancia de la clase A si :
	- B agrega objetos de A.
	- B contiene objetos de A.
	- B registra instancias de objetos de A.
	- B utiliza más estrechamente objetos de A.
	- B tiene los datos de inicialización que se pasarán a A cuando sea creado (B es un Experto con respecto a la creación de A).
	- B es un creador de los objetos A.
	- Si se aplica más de una opción => preferimos: clase B que agregue o contenga a la clase A
## Bajo Acoplamiento

|                                                                                                                             |
| --------------------------------------------------------------------------------------------------------------------------- |
| Acoplamiento: medida de la fuerza con que un elemento está conectado a, tiene conocimiento de, o confía en otros elementos. |

- **Problema:** ¿Cómo soportar bajas dependencias, en miras a la reutilización?
- **Solución:** Asignar una responsabilidad de manera que el acoplamiento permanezca bajo.

## Alta cohesión

|                   |                                                                                                                       |
| ----------------- | --------------------------------------------------------------------------------------------------------------------- |
| Grado de cohesión | Responsabilidades                                                                                                     |
| Muy baja          | Una única clase es responsable de muchas cosas en áreas funcionales muy diferentes.                                   |
| Baja              | Una única clase tiene la responsabilidad de una tarea compleja en un área funcional.                                  |
| Alta              | Una clase tiene una responsabilidad moderada en un área funcional y colabora con otras para llevar a cabo las tareas. |
| Moderada          | Una clase tiene responsabilidades ligeras y únicas en unas pocas áreas lógicamente relacionadas.                      |

- **Problema:** Un elemento con responsabilidades altamente relacionadas, que no hace gran cantidad de trabajo, tiene alta cohesión.
- **Solución:** Asignar una responsabilidad para que la cohesión permanezca alta.
- **Importante:** La cohesión no se puede considerar de modo aislado como los patrones Experto y Bajo Acoplamiento.
## Controlador

|                                                                                                                                                                                                    |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Un evento del sistema es una acción de entrada generada por un actor (agente externo). Se asocian a operaciones del sistema, pero no son lo mismo, las operaciones son la respuesta a los eventos. |

- **Problema:** ¿Quién debe ser el responsable de gestionar un evento del sistema?
- **Solución:** Asignar la responsabilidad de recibir o manejar un mensaje de evento del sistema a una clase que:
	- Representa el sistema global, dispositivo o subsistema (controlador de fachada).
	- Representa un escenario de caso de uso donde ocurre ese evento del sistema.
	- El controlador puede ser de fachada o de casos de uso.
	- Nombres: 
	- 'NombreDelCasoDeUso' Manejador o 	- 'NombreDelCaso-DeUso' Controlador. 

- **Importante:** Use la misma clase controlador para todos los eventos del sistema dentro del mismo caso de uso. Las clases “ventana”, “applet”, “widget”, “vista” y “documento” no deben ser controladores. Estas clases reciben eventos y los delegan a un controlador.

# Polimorfismo

|                                                                                                                                   |
| --------------------------------------------------------------------------------------------------------------------------------- |
| Polimorfismo:  asignar el mismo nombre a servicios en diferentes objetos cuando los servicios son parecidos o están relacionados. |
- **Problema:** ¿Cómo manejar las alternativas basadas en el tipo? ¿Cómo crear componentes conectables (pluggable)? 
- **Solución:** Cuando los comportamientos varían según el tipo, asigne responsabilidad para manejar el comportamiento (con operaciones polimórficas) a las clases para las que varía el comportamiento.
- **Importante:** es básicamente el adaptador.
 
# **Fabricación Pura**

- **Problema:** ¿Qué objetos deberían tener la responsabilidad cuando las soluciones que ofrece el Experto no son adecuadas, sin violar Alta Cohesión y Bajo Acoplamiento, u otros? Hay situaciones donde la asignación de las responsabilidades sólo a las clases de la capa del dominio da lugar a problemas en cuanto a cohesión y acoplamiento => el potencial a reutilizar es bajo.    
- **Solución:** Asigne responsabilidades a una clase artificial o de conveniencia que no representa un concepto del dominio del problema. Algo inventado para soportar alta cohesión, bajo acoplamiento y reutilización.
- **Importante:** los objetos de fabricación pura no son conceptos del dominio, fueron creados para facilitar las cosas al desarrollador. Se suelen organizar en base a funcionalidad relacionada, son objetos centrados base a su función o comportamiento. El ejemplo más claro son los manejadores de bases de datos.

## **Indirección**

- **Problema:** ¿Dónde asignar una responsabilidad, para evitar el acoplamiento directo entre dos (o más) cosas? ¿Cómo desacoplar objetos para que se soporte bajo acoplamiento y el potencial para reutilizar permanezca alto?
- **Solución:** Asigne responsabilidad a un objeto intermedio que medie entre otros componentes o servicios de manera que no se acoplen directamente. El intermediario crea una indirección entre los otros componentes

## **Variaciones Protegidas**

- **Problema:** ¿Cómo diseñar objetos, subsistemas y sistemas para que las variaciones o inestabilidades en estos elementos no tengan un impacto no deseable en otros elementos? 
- **Solución:** Identifique los puntos de variaciones previstas o de inestabilidad y cree interfaz estable alrededor de ellos.
- **Ejemplo:**  El problema del calculador de impuestos externo y su solución con el Polimorfismo. El punto de inestabilidad o variación son las diferentes interfaces o APIs de calculadores de impuestos externos, el sistema de PDV debe integrarse con muchos sistemas de cálculo de impuestos existentes y futuros. Añadiendo un nivel de indirección, una interfaz y usando polimorfismo con varias implementaciones de IAdaptadorCalculadorDeImpuestos protegemos al sistema de las variaciones en las APIs externas. De esta manera los objetos internos colaboran con una interfaz estable; las distintas implementaciones del adaptador ocultan variaciones de los sistemas externos.
- **Importante:** La mayoría de los patrones son mecanismos para variaciones protegidas.