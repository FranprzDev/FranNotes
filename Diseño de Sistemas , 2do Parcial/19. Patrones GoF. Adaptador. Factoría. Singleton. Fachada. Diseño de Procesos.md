Son 23 patrones útiles para diseño de objetos que provienen del libro **Design Patterns** escrito por 4 autores.

## Patrón Adaptador (GoF)
**Problema:** ¿Cómo resolver interfaces incompatibles o proporcionar una interfaz estable para componentes parecidos, con diferentes interfaces?
**Solución:** Convertir la interfaz origina de un componente en otra interfaz, mediante un objeto adaptador intermedio. 
Ejemplo:
![[Pasted image 20241123115418.png]]
La aplicación del **patrón adaptador** es una especialización de los componetes básicos de **GRASP**, Es decir, es una combinación de **Variaciones Protegidas e Indirección.**
Este patrón se agrega como un descubrimiento incremental ya que es parte de conceptos relevantes del dominio, que es importante agregarlo al modelo del dominio.
**Patrones relacionados:**
Un **adaptador** de recursos que oculta un sistema externo también puede ser una **fachada.**

## Patrón Factoría
Se basa en un principio fundamental de diseño; que es **mantener separado los intereses** (separation of concerns). Donde recomienda dividir los módulos y tenerlos separados en distintas áreas diferentes que cada una tenga un propósito cohesivo entre sí.

**Problema:** ¿Quién debe ser el responsable de crear objetos cuando existen consideraciones especiales? (Lógica de creación compleja, o haya que separar responsabilidades para mejorar la creación).
**Solución:** Crear un objeto **Fabricación pura** denominado Factoría que maneje la creación.
**Patrones relacionados**:
- A veces accedemos a las factorías con el singleton
**Ventajas:**
- Separan la responsabilidad de la creación compleja con **objetos de apoyo (helper)**
- Ocultan la lógica de **creación compleja**

## Singleton
**Problema:** Los objetos necesitan un único punto de acceso global. 
**Solución**: A través de la definición de un método estático de la clase que devuelva el Singleton, así logrando visibilidad global de esta instancia y poder utilizarla para todo.
**Ejemplo:**
*public static void Singleton () {}*

**Patrones relacionados:** Podemos utilizar **Factoría** y **Fachada**

## Fachada
**Problema:** Se necesita una interfaz común, unificada para un conjunto de implementaciones o interfaces disapres.
**Solución**: Definir un único punto de conexión con el subsistema en cuestión, es decir un objeto **Fachada** que sea el encargado de comunicarse con el subsistema. El objeto fachada presenta una única interfaz que es capaz de colaborar con todos los componentes del subsistema.
**Patrones relacionados:** Podemos acceder a **fachada** por medio de un **Singleton**. Tanto fachada como singleton; utilizan **variaciones protegidas** ya que añaden un objeto **indirección** que ayuda a mantener el **Bajo Acoplamiento**
Al realizar una fachada logramos una **separación de intereses** ya que estamos delegando todas las cuestiones del manejo de reglas.
Es bastante similar al **adaptador**, de hecho es una clase de **fachada** pero difiere porque este proporciona adaptación a **interfaces diferentes**, debido a esto se llama **Adaptador.**

## **Diseño de Procesos**
**Paso a paso para elaborar un diagrama de interacción.**
****
**Relación entre los artefactos**
Los caos de uso indican los eventos del sistema que se muestran explícitamente en los **diagramas de secuencia**
Los **efectos** producidos por los **eventos del sistema** se describen en los **contratos**
![[Pasted image 20241123140341.png]]

Los eventos del sistema pasan a ser los **mensajes iniciadores de los Diagramas de Interacción** y describen visualmente **como los objetos interactúan para realizar esa operación solicitada.**

**IMPORTANTE:**
Cada evento debe tener un contrato.